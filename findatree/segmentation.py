from typing import List
from typing import Tuple
import numpy as np
import cv2 as cv
import numba
import importlib

from scipy.spatial import distance_matrix
from scipy.ndimage.morphology import distance_transform_edt as distance_transform

import skimage.measure as measure
import skimage.transform as transform
import skimage.filters as filters
import skimage.morphology as morph
import skimage.segmentation as segmentation
import skimage.feature as feature

import findatree.io as io

importlib.reload(io)

#%%
def scaler_percentile(img_in, percentile=0, mask=None, return_dtype='uint8'):
    '''
    Rescale image to interval ``[0,1]`` based on percentile ``(p_lower = percentile, p_upper = 100 - percentile)``
    '''

    # Copy input image
    img = img_in.copy()

    # Define mask if not set
    if mask is None:
        mask = np.ones(img.shape, dtype=np.bool_)

    # Percentile scaling
    thresh_lower = max(np.nanpercentile(img[mask], percentile), 0)
    thresh_upper = np.nanpercentile(img[mask], 100 - percentile)
    img -= thresh_lower
    img /= (thresh_upper - thresh_lower)
    img[img < 0] = 0
    img[img > 1] = 1
    
    # dtype conversion
    if return_dtype == 'uint8': 
        img = img * 255
        img = img.astype(np.uint8)
        img[np.invert(mask)] = 0

    return img, (thresh_lower, thresh_upper)


#%%
def local_thresholding(img_in, mask, width, resolution, blur=True):
    '''
    Local gaussian thresholding of image.
    '''
    # Set everything outside global mask to 0
    img = img_in.copy()
    img[np.invert(mask)] = 0

    # Apply median blurring before application of local threshold
    if blur:
        img = filters.median(
            img,
            footprint=morph.square(3),
            )

    # Kernel width
    width_px = width / resolution
    width_px = int(np.round(width_px))
    if width_px % 2 == 0:
        width_px +=1 
    
    # Print kernel width
    print(f"    ... (thresholding) Gaussian thresholding kernel width: {width:.1f} [m] = {width_px:.0f} [px]")

    # Local thresholding
    thresh = filters.threshold_local(
        img,
        block_size=width_px,
        method='gaussian',
    )
    mask_local = (img > thresh).astype(np.uint8)

    return mask_local


#%%
def watershed_by_peaks_in_disttrafo(image, mask, peak_min_distance, px_width):
    '''
    Marker based watersheding of image.
    Markers are generated by:
        1. Removing small holes (``area = 0.2 [m**2]``) of mask
        2. Computing distance transform (-> ``dist``) of mask 
        3. Finding local peaks within ``dist`` separated by minimum distance ``min_distance``.
    Marker based watersheding is finally carried out on ``- dist * image``.
    '''

    # Remove small holes in mask
    area_thresh = 0.
    area_thresh_px = int(np.round(area_thresh / px_width**2))
    print(f"    ... (watershed) Removing holes of area: {area_thresh:.2f} [m**2] = {area_thresh_px:.0f} [px]")
    mask = morph.remove_small_holes(
        mask.astype(np.bool_),
        area_threshold=area_thresh_px,
        connectivity=1,
    )
    mask = mask.astype(np.uint8)

    # Distance transform of mask
    dist = distance_transform(mask)

    # Set & print minimum distance in [m] and [px]
    peak_min_distance_px = int(np.floor(peak_min_distance / px_width))
    print(f"    ... (watershed) Peaks in distance transform separated by minimum distance: {peak_min_distance:.1f} [m] = {peak_min_distance_px:.0f} [px]")

    # Find local peaks in distance transform of mask
    peaks_idx = feature.peak_local_max(dist, min_distance=peak_min_distance_px)
    peaks = np.zeros_like(mask,dtype=np.uint8)
    peaks[tuple(peaks_idx.T)] = 1
 
    # Label peaks to generate markers
    markers = measure.label(peaks, background=0, return_num=False, connectivity=2)

    # Expand marker without overlap before watershed
    marker_expansion = int(np.floor(0.8 / px_width))
    markers = segmentation.expand_labels(
        markers,
        distance=marker_expansion,
    )
    markers[np.invert(mask.astype(np.bool_))] = 0 # Restrict markers to mask

    # Prepare output mask + markers -> mask_seed
    mask_seed = mask + markers
    mask_seed[mask_seed > 2] = 2

    # Watershed
    labels = segmentation.watershed(
        - dist * image,
        markers=markers, 
        mask=mask,
        watershed_line=True,
    )

    # Remove contracted, small labels after watershed
    labels = morph.remove_small_objects(
        labels,
        min_size=5,
        connectivity=1,
    )

    # Relabel in sequential manner after removing contracted labels
    labels = segmentation.relabel_sequential(labels)[0]

    # Watershed again, after removing contracted and sequential relabeling
    labels = segmentation.watershed(
        - dist * image,
        markers=labels, 
        mask=mask,
    )

    return labels, mask_seed


#%%
def labels_to_bounds(labels):
    '''
    Return boundaries of labels, i.e. integer labeled connected components in image.
    '''
    bounds = segmentation.find_boundaries(
        labels,
        connectivity=1,
        mode='outer',
    ).astype(np.uint8)
    bounds = morph.thin(bounds)

    return bounds


#%%
def labels_resize(labels, shape):
    '''
    Resize labels to a defined shape.
    '''
    labels_resize = transform.resize(
        labels,
        output_shape=shape,
        order=0,
        preserve_range=True,
        )
    
    return labels_resize


#%%
def main(
    cs_primary,
    px_width,
    thresh_dict={},
    water_dict={},
    ):

    ######################################### (0) Set standard settings if not set
    ########### (A) Thresholding
    thresh_dict_standard = {
        'channel': 'l',
        'downscale': 1,
        'blur': False,
        'width': 30,
    }
    thresh_dict_keys = [k for k in thresh_dict]
    for k in thresh_dict_standard:
        if k in thresh_dict_keys:
            thresh_dict[k] = thresh_dict[k]
        else:
            thresh_dict[k] = thresh_dict_standard[k]

    ########### (B) Watershed
    water_dict_standard = {
        'channel': 'l',
        'downscale': 0,
        'peak_dist': 1.2,
    }
    water_dict_keys = [k for k in water_dict]
    for k in water_dict_standard:
        if k in water_dict_keys:
            water_dict[k] = water_dict[k]
        else:
            water_dict[k] = water_dict_standard[k]


    ######################################### (1) Normalize channels for thresholding and watershed
    cs_thresh, shape_in, shape_thresh = io.define_channels(cs_primary, downscale=thresh_dict['downscale'])
    thresh_dict['shape'] = shape_thresh
    thresh_dict['px_width'] = px_width * 2**thresh_dict['downscale']

    cs_water, shape_in, shape_water = io.define_channels(cs_primary, downscale=water_dict['downscale'])
    water_dict['shape'] = shape_water
    water_dict['px_width'] = px_width * 2**water_dict['downscale']

    # Print final parameters
    print('Thresholding params.:')
    print(thresh_dict)
    print('Watershed params.:')
    print(water_dict)
    print()

    ######################################### (2) Set global mask
    mask_global_thresh = (cs_thresh['chm'] > 3) & (cs_thresh['ndvi'] > 0.4)


    ######################################### (3) Local gaussian thresholding
    # Channel used for local thresholding
    img_thresh = cs_thresh[thresh_dict['channel']].copy()

    # Gaussian local thresholding
    mask_local_thresh = local_thresholding(
        img_thresh,
        mask=mask_global_thresh,
        width=thresh_dict['width'],
        resolution=thresh_dict['px_width'],
        blur=thresh_dict['blur'],
        )


    ######################################### (4) Re-upscale masks for watershed
    # Upscale tresholding masks to original resolution
    mask_global_water = labels_resize(mask_global_thresh, shape=water_dict['shape']).astype(np.bool_)
    mask_local_water = labels_resize(mask_local_thresh, shape=water_dict['shape']).astype(np.bool_)


    ######################################### (5) Marker based watershed based on local peaks in distance transform of local mask
    # Channel used for watershed
    if water_dict['channel'] is None:
        img_water = np.ones_like(mask_local_water)
    else:
        img_water = cs_water[water_dict['channel']].copy()

    # Label by marker based watershed based on local peaks of distance transform of local mask
    labels_water, mask_seed_water = watershed_by_peaks_in_disttrafo(
        img_water,
        mask=mask_local_water,
        peak_min_distance=water_dict['peak_dist'],
        px_width=water_dict['px_width'],
    )

    ######################################### (6) Resize labels/bounds/masks
    labels = labels_resize(labels_water, shape=shape_in)
    mask_global = labels_resize(mask_global_water, shape=shape_in)
    mask_seed = labels_resize(mask_seed_water, shape=shape_in)
    bounds= labels_to_bounds(labels)

    return labels, bounds, mask_seed, mask_global, thresh_dict, water_dict

