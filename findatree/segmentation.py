from typing import List
from typing import Tuple
import numpy as np
import cv2 as cv
import numba
import importlib

from scipy.spatial import distance_matrix
from scipy.ndimage.morphology import distance_transform_edt as distance_transform

import skimage.measure as measure
import skimage.transform as transform
import skimage.filters as filters
import skimage.morphology as morph
import skimage.segmentation as segmentation
import skimage.feature as feature

import findatree.io as io

importlib.reload(io)

#%%
def local_thresholding(img_in, mask, width, px_width, blur=True):
    '''
    Local gaussian thresholding of image.
    '''
    # Set everything outside global mask to 0
    img = img_in.copy()
    img[np.invert(mask)] = 0

    # Apply median blurring before application of local threshold
    if blur:
        img = filters.median(
            img,
            footprint=morph.square(3),
            )

    # Kernel width
    width_px = width / px_width
    width_px = int(np.round(width_px))
    if width_px % 2 == 0:
        width_px +=1 
    
    # Print kernel width
    print(f"    ... [segmentation.local_thresholding()] Gaussian thresholding kernel width: {width:.1f} [m] = {width_px:.0f} [px]")

    # Local thresholding
    thresh = filters.threshold_local(
        img,
        block_size=width_px,
        method='gaussian',
    )
    mask_local = (img > thresh).astype(np.uint8)

    return mask_local


#%%
def watershed_by_peaks_in_disttrafo(image, mask, peak_min_distance, px_width, area_thresh, label_min_size):
    '''
    Marker based watersheding of image.
    Markers are generated by:
        1. Removing small holes (``area = 0.2 [m**2]``) of mask
        2. Computing distance transform (-> ``dist``) of mask 
        3. Finding local peaks within ``dist`` separated by minimum distance ``min_distance``.
    Marker based watersheding is finally carried out on ``- dist * image``.
    '''

    # Remove small holes in mask
    area_thresh_px = int(np.round(area_thresh / px_width**2))
    print(f"    ... [segmentation.watershed_by_peaks_in_disttrafo()] Removing holes of area: {area_thresh:.2f} [m**2] = {area_thresh_px:.0f} [px]")
    mask = morph.remove_small_holes(
        mask.astype(np.bool_),
        area_threshold=area_thresh_px,
        connectivity=1,
    )
    mask = mask.astype(np.uint8)

    # Distance transform of mask
    dist = distance_transform(mask)

    # Set & print minimum distance in [m] and [px]
    peak_min_distance_px = int(np.floor(peak_min_distance / px_width))
    print(f"    ... [segmentation.watershed_by_peaks_in_disttrafo()] Peaks in distance transform separated by minimum distance: {peak_min_distance:.1f} [m] = {peak_min_distance_px:.0f} [px]")

    # Find local peaks in distance transform of mask
    peaks_idx = feature.peak_local_max(dist, min_distance=peak_min_distance_px)
    peaks = np.zeros_like(mask,dtype=np.uint8)
    peaks[tuple(peaks_idx.T)] = 1
 
    # Label peaks to generate markers
    markers = measure.label(peaks, background=0, return_num=False, connectivity=2)

    # Expand marker without overlap before watershed
    marker_expansion = int(np.floor(0.8 / px_width))
    markers = segmentation.expand_labels(
        markers,
        distance=marker_expansion,
    )
    markers[np.invert(mask.astype(np.bool_))] = 0 # Restrict markers to mask

    # Prepare output mask + markers -> mask_seed
    mask_seed = mask + markers
    mask_seed[mask_seed > 2] = 2

    # Watershed
    labels = segmentation.watershed(
        - dist * image,
        markers=markers, 
        mask=mask,
        watershed_line=True,
    )

    # Remove contracted, small labels after watershed
    labels = morph.remove_small_objects(
        labels,
        min_size=label_min_size,
        connectivity=1,
    )

    # Relabel in sequential manner after removing contracted labels
    labels = segmentation.relabel_sequential(labels)[0]

    # Watershed again, after removing contracted and sequential relabeling
    labels = segmentation.watershed(
        - dist * image,
        markers=labels, 
        mask=mask,
    )

    return labels, mask_seed


#%%
def labels_to_bounds(labels):
    '''
    Return boundaries of labels, i.e. integer labeled connected components in image.
    '''
    bounds = segmentation.find_boundaries(
        labels,
        connectivity=1,
        mode='outer',
    ).astype(np.uint8)
    bounds = morph.thin(bounds)

    return bounds


#%%
def labels_resize(labels, shape):
    '''
    Resize labels to a defined shape.
    '''
    labels_resize = transform.resize(
        labels,
        output_shape=shape,
        order=0,
        preserve_range=True,
        )
    
    return labels_resize


#%%
def main(
    cs,
    params_cs,
    params,
    verbose=True,
    ):

    ######################################### (0) Set standard settings if not set
    params_standard = {
        'thresh_global_chm': 3,
        'thresh_global_ndvi': 0.4,
        'thresh_channel': 'l',
        'thresh_downscale': 1,
        'thresh_blur': False,
        'thresh_width': 30,
        'water_channel': 'l',
        'water_downscale': 0,
        'water_peak_dist': 1.2,
        'water_area_thresh': 0.,
        'water_label_min_size': 5,
    }
    params_keys = [k for k in params]
    for k in params_standard:
        if k in params:
            params[k] = params[k]
        else:
            params[k] = params_standard[k]

    ######################################### (1) Prepare channels at defined px_widths for thresholding and watershed
    cs_thresh, params_thresh = io.channels_primary_to_secondary(cs, params_cs, downscale=params['thresh_downscale'], verbose=False)
    params['thresh_shape'] = params_thresh['shape']
    params['thresh_px_width'] = params_thresh['px_width']

    cs_water, params_water = io.channels_primary_to_secondary(cs, params_cs, downscale=params['water_downscale'], verbose=False)
    params['water_shape'] = params_water['shape']
    params['water_px_width'] = params_water['px_width']


    ######################################### (2) Set global mask
    mask_global_thresh = (cs_thresh['chm'] > params['thresh_global_chm']) & (cs_thresh['ndvi'] > params['thresh_global_ndvi'])


    ######################################### (3) Local gaussian thresholding
    # Channel used for local thresholding
    img_thresh = cs_thresh[params['thresh_channel']].copy()

    # Gaussian local thresholding
    mask_local_thresh = local_thresholding(
        img_thresh,
        mask=mask_global_thresh,
        width=params['thresh_width'],
        px_width=params['thresh_px_width'],
        blur=params['thresh_blur'],
        )


    ######################################### (4) Re-upscale masks for watershed
    # Upscale tresholding masks to original resolution
    mask_global_water = labels_resize(mask_global_thresh, shape=params['water_shape']).astype(np.bool_)
    mask_local_water = labels_resize(mask_local_thresh, shape=params['water_shape']).astype(np.bool_)


    ######################################### (5) Marker based watershed based on local peaks in distance transform of local mask
    # Channel used for watershed
    if params['water_channel'] is None:
        img_water = np.ones_like(mask_local_water)
    else:
        img_water = cs_water[params['water_channel']].copy()

    # Label by marker based watershed based on local peaks of distance transform of local mask
    labels_water, mask_seed_water = watershed_by_peaks_in_disttrafo(
        img_water,
        mask=mask_local_water,
        peak_min_distance=params['water_peak_dist'],
        px_width=params['water_px_width'],
        area_thresh=params['water_area_thresh'],
        label_min_size=params['water_label_min_size'],
    )

    ######################################### (6) Resize labels/bounds/masks
    labels = labels_resize(labels_water, shape=params_cs['shape'])
    mask_global = labels_resize(mask_global_water, shape=params_cs['shape'])
    mask_seed = labels_resize(mask_seed_water, shape=params_cs['shape'])
    bounds= labels_to_bounds(labels)

    # Prepare return channels
    cs_segment = {}
    cs_segment['labels'] = labels
    cs_segment['bounds'] = bounds
    cs_segment['mask_seed'] = mask_seed
    cs_segment['mask_global'] = mask_global

    # Print parameters
    if verbose:
        print('-----------')
        print('Parameters:')
        for k in params: print(f"  {k:<30}: {params[k]}")

    return cs_segment, params

